{
  "articles": [
    {
      "id": "1765689229535",
      "title": "C++数据结构——链表",
      "desc": "",
      "content": "## 链表基础与核心概念\n链表是一种动态数据结构，它通过指针将一组零散的内存块串联起来使用。与数组相比，链表在插入和删除操作上更加高效，但失去了随机访问的能力。\n\n### 为什么使用链表？\n\n 1.动态大小：不需要预先知道数据量大小\n 2.高效插入/删除：O(1)时间复杂度（已知位置时）\n 3.内存效率：不需要连续内存空间\n\n## 一、链表核心组件详解\n\n### 1. ListNode 结构体深度解析\n\ncpp\nstruct ListNode {\n int val; // 数据域 - 存储节点值\n ListNode* next; // 指针域 - 指向下一个节点\n \n // 构造函数家族\n ListNode() : val(0), next(nullptr) {\n // 默认构造函数，创建空节点\n }\n \n ListNode(int x) : val(x), next(nullptr) {\n // 带值构造函数，next自动初始化为nullptr\n // 确保新节点不会意外指向其他内存\n }\n \n ListNode(int x, ListNode* next) : val(x), next(next) {\n // 完整构造函数，允许指定下一个节点\n // 常用于构建特定结构的链表\n }\n \n // 析构函数（高级用法）\n ~ListNode() {\n // 注意：通常不在节点析构函数中处理next指针\n // 因为链表管理应由链表类负责\n // 但如果节点包含需要清理的资源，可以在此处理\n }\n \n // 成员函数示例（高级用法）\n void setNext(ListNode* node) {\n next = node;\n }\n \n ListNode* getNext() const {\n return next;\n }\n \n int getValue() const {\n return val;\n }\n \n void setValue(int value) {\n val = value;\n }\n};\n\n\n**关键点说明**：\n- `next`指针必须正确初始化，否则会成为野指针\n- 构造函数重载提供了多种创建节点的方式\n- 析构函数通常保持简单，复杂清理应由链表类处理\n- 添加成员函数可以封装节点操作，提高安全性\n\n### 2. LinkedList 类完整实现\n\ncpp\nclass LinkedList {\nprivate:\n ListNode* head; // 头节点指针\n ListNode* tail; // 尾节点指针（优化尾部操作）\n size_t size; // 链表长度（使用size_t避免负数）\n \n // 私有工具函数\n ListNode* getNodeAt(int index) const {\n if (index < 0 || index >= size) return nullptr;\n \n ListNode* current = head;\n for (int i = 0; i < index; ++i) {\n current = current->next;\n }\n return current;\n }\n \npublic:\n // 构造函数家族\n LinkedList() : head(nullptr), tail(nullptr), size(0) {\n // 默认构造空链表\n }\n \n LinkedList(std::initializer_list<int> initList) : LinkedList() {\n // 初始化列表构造\n for (int val : initList) {\n append(val);\n }\n }\n \n // 拷贝构造函数（深拷贝）\n LinkedList(const LinkedList& other) : LinkedList() {\n ListNode* current = other.head;\n while (current != nullptr) {\n append(current->val);\n current = current->next;\n }\n }\n \n // 移动构造函数（C++11）\n LinkedList(LinkedList&& other) noexcept \n : head(other.head), tail(other.tail), size(other.size) {\n other.head = other.tail = nullptr;\n other.size = 0;\n }\n \n // 析构函数\n ~LinkedList() {\n clear(); // 确保释放所有节点\n }\n \n // 赋值运算符重载\n LinkedList& operator=(const LinkedList& other) {\n if (this != &other) {\n clear();\n ListNode* current = other.head;\n while (current != nullptr) {\n append(current->val);\n current = current->next;\n }\n }\n return *this;\n }\n \n // 移动赋值运算符（C++11）\n LinkedList& operator=(LinkedList&& other) noexcept {\n if (this != &other) {\n clear();\n head = other.head;\n tail = other.tail;\n size = other.size;\n other.head = other.tail = nullptr;\n other.size = 0;\n }\n return *this;\n }\n \n // 容量操作\n bool isEmpty() const { return size == 0; }\n size_t getSize() const { return size; }\n \n // 元素访问（带边界检查）\n int& operator[](int index) {\n ListNode* node = getNodeAt(index);\n if (node == nullptr) {\n throw std::out_of_range(\"Index out of bounds\");\n }\n return node->val;\n }\n \n const int& operator[](int index) const {\n return const_cast<LinkedList*>(this)->operator[](index);\n }\n \n int front() const {\n if (isEmpty()) throw std::out_of_range(\"List is empty\");\n return head->val;\n }\n \n int back() const {\n if (isEmpty()) throw std::out_of_range(\"List is empty\");\n return tail->val;\n }\n \n // 修改操作\n void append(int value) {\n ListNode* newNode = new ListNode(value);\n \n if (isEmpty()) {\n head = tail = newNode;\n } else {\n tail->next = newNode;\n tail = newNode;\n }\n ++size;\n }\n \n void prepend(int value) {\n ListNode* newNode = new ListNode(value, head);\n head = newNode;\n if (tail == nullptr) {\n tail = head;\n }\n ++size;\n }\n \n bool insert(int index, int value) {\n if (index < 0 || index > size) return false;\n \n if (index == 0) {\n prepend(value);\n } else if (index == size) {\n append(value);\n } else {\n ListNode* prev = getNodeAt(index - 1);\n ListNode* newNode = new ListNode(value, prev->next);\n prev->next = newNode;\n ++size;\n }\n return true;\n }\n \n bool removeAt(int index) {\n if (index < 0 || index >= size) return false;\n \n ListNode* toDelete = nullptr;\n \n if (index == 0) {\n toDelete = head;\n head = head->next;\n if (head == nullptr) {\n tail = nullptr;\n }\n } else {\n ListNode* prev = getNodeAt(index - 1);\n toDelete = prev->next;\n prev->next = toDelete->next;\n \n if (toDelete == tail) {\n tail = prev;\n }\n }\n \n delete toDelete;\n --size;\n return true;\n }\n \n void clear() {\n while (head != nullptr) {\n ListNode* temp = head;\n head = head->next;\n delete temp;\n }\n tail = nullptr;\n size = 0;\n }\n \n // 高级操作\n void reverse() {\n ListNode *prev = nullptr, *current = head, *next = nullptr;\n tail = head; // 反转后尾节点变为原头节点\n \n while (current != nullptr) {\n next = current->next; // 保存下一个节点\n current->next = prev; // 反转当前节点的指针\n prev = current; // 移动prev指针\n current = next; // 移动current指针\n }\n \n head = prev; // 最后prev指向新的头节点\n }\n \n // 迭代器支持（简化版）\n class Iterator {\n ListNode* current;\n public:\n Iterator(ListNode* node) : current(node) {}\n \n int& operator*() { return current->val; }\n Iterator& operator++() { \n current = current->next; \n return *this;\n }\n bool operator!=(const Iterator& other) const {\n return current != other.current;\n }\n };\n \n Iterator begin() { return Iterator(head); }\n Iterator end() { return Iterator(nullptr); }\n \n // 输出链表\n friend std::ostream& operator<<(std::ostream& os, const LinkedList& list) {\n ListNode* current = list.head;\n os << \"[\";\n while (current != nullptr) {\n os << current->val;\n if (current->next != nullptr) {\n os << \" -> \";\n }\n current = current->next;\n }\n os << \"]\";\n return os;\n }\n};\n\n\n## 二、高级特性深度解析\n\n### 1. 迭代器实现详解\n\ncpp\n// 完整迭代器实现\nclass Iterator {\n ListNode* current;\npublic:\n using iterator_category = std::forward_iterator_tag;\n using value_type = int;\n using difference_type = std::ptrdiff_t;\n using pointer = int*;\n using reference = int&;\n \n explicit Iterator(ListNode* node = nullptr) : current(node) {}\n \n // 解引用运算符\n reference operator*() const {\n if (current == nullptr) {\n throw std::runtime_error(\"Dereferencing null iterator\");\n }\n return current->val;\n }\n \n // 成员访问运算符\n pointer operator->() const {\n return &(operator*());\n }\n \n // 前缀++\n Iterator& operator++() {\n if (current != nullptr) {\n current = current->next;\n }\n return *this;\n }\n \n // 后缀++\n Iterator operator++(int) {\n Iterator temp = *this;\n ++(*this);\n return temp;\n }\n \n // 相等比较\n bool operator==(const Iterator& other) const {\n return current == other.current;\n }\n \n bool operator!=(const Iterator& other) const {\n return !(*this == other);\n }\n \n // 转换为bool（判断是否有效）\n explicit operator bool() const {\n return current != nullptr;\n }\n \n // 获取内部指针（高级用法）\n ListNode* node() const {\n return current;\n }\n};\n\n\n**使用示例**：\ncpp\nLinkedList list = {1, 2, 3, 4, 5};\n\n// 使用迭代器遍历\nfor (LinkedList::Iterator it = list.begin(); it != list.end(); ++it) {\n std::cout << *it << \" \";\n}\n\n// 使用范围for循环（C++11）\nfor (int val : list) {\n std::cout << val << \" \";\n}\n\n// 使用STL算法\nauto it = std::find(list.begin(), list.end(), 3);\nif (it != list.end()) {\n std::cout << \"Found: \" << *it;\n}\n\n\n### 2. 异常安全实现\n\ncpp\n// 异常安全的插入操作\nbool insertSafe(int index, int value) {\n // 先创建新节点（可能抛出bad_alloc）\n ListNode* newNode = nullptr;\n try {\n newNode = new ListNode(value);\n } catch (const std::bad_alloc&) {\n return false; // 内存分配失败\n }\n \n // 空链表情况\n if (isEmpty()) {\n if (index != 0) {\n delete newNode;\n return false;\n }\n head = tail = newNode;\n ++size;\n return true;\n }\n \n // 插入头部\n if (index == 0) {\n newNode->next = head;\n head = newNode;\n ++size;\n return true;\n }\n \n // 插入中间或尾部\n try {\n ListNode* prev = getNodeAt(index - 1);\n if (prev == nullptr && index != size) {\n delete newNode;\n return false;\n }\n \n newNode->next = prev->next;\n prev->next = newNode;\n \n if (prev == tail) {\n tail = newNode;\n }\n \n ++size;\n return true;\n } catch (...) {\n delete newNode;\n throw; // 重新抛出异常\n }\n}\n\n\n### 3. 线程安全扩展（C++11）\n\ncpp\n#include <mutex>\n\nclass ThreadSafeLinkedList {\nprivate:\n LinkedList list;\n mutable std::mutex mtx;\n \npublic:\n void append(int value) {\n std::lock_guard<std::mutex> lock(mtx);\n list.append(value);\n }\n \n bool insert(int index, int value) {\n std::lock_guard<std::mutex> lock(mtx);\n return list.insert(index, value);\n }\n \n // 其他方法的线程安全包装...\n \n // 提供原子快照\n LinkedList snapshot() const {\n std::lock_guard<std::mutex> lock(mtx);\n return list; // 调用拷贝构造函数\n }\n};\n\n\n## 三、性能优化技巧\n\n### 1. 内存池优化\n\ncpp\nclass ListNodePool {\nprivate:\n std::vector<ListNode*> pool;\n size_t chunkSize = 100;\n \n void allocateChunk() {\n pool.reserve(pool.size() + chunkSize);\n for (size_t i = 0; i < chunkSize; ++i) {\n pool.push_back(new ListNode(0));\n }\n }\n \npublic:\n ListNode* acquire(int value) {\n if (pool.empty()) {\n allocateChunk();\n }\n \n ListNode* node = pool.back();\n pool.pop_back();\n node->val = value;\n node->next = nullptr;\n return node;\n }\n \n void release(ListNode* node) {\n if (node != nullptr) {\n node->next = nullptr;\n pool.push_back(node);\n }\n }\n \n ~ListNodePool() {\n for (ListNode* node : pool) {\n delete node;\n }\n }\n};\n\n// 使用内存池的链表\nclass OptimizedLinkedList {\nprivate:\n ListNodePool pool;\n // ... 其他成员\npublic:\n void append(int value) {\n ListNode* newNode = pool.acquire(value);\n // ... 其他操作\n }\n \n void removeAt(int index) {\n // ... 找到要删除的节点\n pool.release(toDelete);\n }\n};\n\n\n### 2. 缓存优化\n\ncpp\nclass CachedLinkedList {\nprivate:\n ListNode* head;\n ListNode* tail;\n size_t size;\n \n // 缓存最近访问的节点\n mutable struct {\n ListNode* node = nullptr;\n int index = -1;\n } cache;\n \n ListNode* getNodeAt(int index) const {\n if (index < 0 || index >= size) return nullptr;\n \n // 检查缓存\n if (cache.index != -1 && std::abs(cache.index - index) < 3) {\n if (cache.index == index) return cache.node;\n \n ListNode* current = cache.node;\n int step = index > cache.index ? 1 : -1;\n \n while (current != nullptr && cache.index != index) {\n current = (step > 0) ? current->next : /* 需要双向链表支持 */;\n cache.index += step;\n }\n \n if (current != nullptr) {\n cache.node = current;\n return current;\n }\n }\n \n // 常规查找\n ListNode* current = head;\n for (int i = 0; i < index; ++i) {\n current = current->next;\n }\n \n // 更新缓存\n cache.node = current;\n cache.index = index;\n \n return current;\n }\n \npublic:\n // ... 其他方法需要清除缓存\n void clear() {\n // ... 原有清理\n cache.node = nullptr;\n cache.index = -1;\n }\n};\n\n\n## 四、实际应用案例\n\n### 1. LRU缓存实现\n\ncpp\nclass LRUCache {\nprivate:\n struct CacheNode {\n int key;\n int value;\n CacheNode* prev;\n CacheNode* next;\n CacheNode(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\n };\n \n std::unordered_map<int, CacheNode*> cacheMap;\n CacheNode* head; // 最近使用的伪头节点\n CacheNode* tail; // 最久未使用的伪尾节点\n int capacity;\n \n void addToHead(CacheNode* node) {\n node->prev = head;\n node->next = head->next;\n head->next->prev = node;\n head->next = node;\n }\n \n void removeNode(CacheNode* node) {\n node->prev->next = node->next;\n node->next->prev = node->prev;\n }\n \n void moveToHead(CacheNode* node) {\n removeNode(node);\n addToHead(node);\n }\n \n CacheNode* removeTail() {\n CacheNode* node = tail->prev;\n removeNode(node);\n return node;\n }\n \npublic:\n LRUCache(int capacity) : capacity(capacity) {\n head = new CacheNode(-1, -1);\n tail = new CacheNode(-1, -1);\n head->next = tail;\n tail->prev = head;\n }\n \n int get(int key) {\n if (!cacheMap.count(key)) return -1;\n \n CacheNode* node = cacheMap[key];\n moveToHead(node);\n return node->value;\n }\n \n void put(int key, int value) {\n if (cacheMap.count(key)) {\n CacheNode* node = cacheMap[key];\n node->value = value;\n moveToHead(node);\n } else {\n if (cacheMap.size() == capacity) {\n CacheNode* removed = removeTail();\n cacheMap.erase(removed->key);\n delete removed;\n }\n \n CacheNode* newNode = new CacheNode(key, value);\n cacheMap[key] = newNode;\n addToHead(newNode);\n }\n }\n \n ~LRUCache() {\n for (auto& pair : cacheMap) {\n delete pair.second;\n }\n delete head;\n delete tail;\n }\n};\n\n\n### 2. 多项式运算实现\n\ncpp\nclass Polynomial {\nprivate:\n struct Term {\n double coefficient;\n int exponent;\n Term* next;\n Term(double coeff, int exp, Term* n = nullptr)\n : coefficient(coeff), exponent(exp), next(n) {}\n };\n \n Term* head;\n \npublic:\n Polynomial() : head(nullptr) {}\n \n void addTerm(double coeff, int exp) {\n if (coeff == 0.0) return;\n \n if (head == nullptr || exp > head->exponent) {\n head = new Term(coeff, exp, head);\n return;\n }\n \n Term* current = head;\n while (current->next != nullptr && current->next->exponent > exp) {\n current = current->next;\n }\n \n if (current->exponent == exp) {\n current->coefficient += coeff;\n if (current->coefficient == 0.0) {\n // 需要删除该节点\n Term* toDelete = current;\n if (current == head) {\n head = head->next;\n } else {\n // 需要找到前驱节点\n Term* prev = head;\n while (prev->next != current) {\n prev = prev->next;\n }\n prev->next = current->next;\n }\n delete toDelete;\n }\n } else {\n current->next = new Term(coeff, exp, current->next);\n }\n }\n \n Polynomial add(const Polynomial& other) const {\n Polynomial result;\n Term* p1 = head;\n Term* p2 = other.head;\n \n while (p1 != nullptr && p2 != nullptr) {\n if (p1->exponent > p2->exponent) {\n result.addTerm(p1->coefficient, p1->exponent);\n p1 = p1->next;\n } else if (p1->exponent < p2->exponent) {\n result.addTerm(p2->coefficient, p2->exponent);\n p2 = p2->next;\n } else {\n double sum = p1->coefficient + p2->coefficient;\n if (sum != 0.0) {\n result.addTerm(sum, p1->exponent);\n }\n p1 = p1->next;\n p2 = p2->next;\n }\n }\n \n // 处理剩余项\n while (p1 != nullptr) {\n result.addTerm(p1->coefficient, p1->exponent);\n p1 = p1->next;\n }\n \n while (p2 != nullptr) {\n result.addTerm(p2->coefficient, p2->exponent);\n p2 = p2->next;\n }\n \n return result;\n }\n \n // ... 其他多项式运算\n};\n\n\n## 六、性能分析与优化\n时间复杂度分析\n\n操作 | 时间复杂度 | 说明\n| :---: | :---: | :---: |\n访问 | O(n) | 需要遍历\n搜索 | O(n) | 需要遍历\n插入 | O(1) | 已知位置时\n删除 | O(1) | 已知位置时\n头部操作|O(1)|直接操作头指针\n尾部操作|O(1)|有尾指针时\n中间操作|O(n)|需要先找到位置\n\n优化建议\n\n1.维护尾指针：可以显著提高尾部操作效率\n2.双向链表：对于需要频繁前向/后向遍历的场景\n3.循环链表：适合环形缓冲区等应用场景\n4.跳表：对于需要快速查找的有序链表\n\n链表作为基础数据结构，其实现质量直接影响程序性能和稳定性。通过深入理解指针操作、内存管理和各种优化技巧，可以构建出高效可靠的链表实现。",
      "tags": [
        "C++"
      ],
      "createTime": "2025-12-14T05:13:49.535Z"
    },
    {
      "id": "test1",
      "title": "测试文章",
      "desc": "测试摘要",
      "content": "## 二级标题\n这是行内公式：$E=mc^2$\n```cpp\n#include <iostream>\nint main() { cout << \"Hello\" << endl; return 0; }\n```\n$$\\sum_{i=1}^n i = \\frac{n(n+1)}{2}$$",
      "tags": [
        "测试",
        "C++",
        "公式"
      ],
      "createTime": "2025-12-13"
    },
    {
      "id": "1765611925220",
      "title": "C++数据结构——Vector",
      "desc": "Vector 是 C++ 中非常实用的容器，它提供了动态数组的功能，并支持各种操作。掌握 vector 的用法对于编写高效、易维护的 C++ 代码至关重要。",
      "content": "Vector 是 C++ 标准模板库 (STL) 中最常用的容器之一，它本质上是一个动态数组，能够存储相同类型的元素，并可以根据需要自动调整大小。本文将详细介绍 vector 的常用函数及其使用方法。\n\n### 一、Vector 的创建与初始化\n\n**1. 包含头文件**\n\n使用 vector 前，需要包含头文件 `<vector>`：\n\n```cpp\n#include <vector>\n```\n\n**2. 创建 vector 对象**\n\n* **空 vector:** 创建一个不包含任何元素的 vector。\n\n```cpp\nstd::vector<int> myVector;//创建一个 int 类型的空 vector\n```\n\n* **指定大小:** 创建一个包含 n 个元素的 vector，默认值为 0。\n\n```cpp\nstd::vector<int> myVector(10); // 创建包含 10 个元素的 vector\n```\n\n* **指定大小和初始值:** 创建一个包含 n 个元素的 vector，并将每个元素初始化为 value。\n\n```cpp\nstd::vector<int> myVector(10, 5); // 创建包含 10 个元素的 vector，每个元素初始化为 5\n```\n\n* **使用列表初始化:** 使用花括号 `{}` 直接初始化 vector。\n\n```cpp\nstd::vector<int> myVector = {1, 2, 3, 4, 5};\n```\n\n* **拷贝构造:** 使用另一个 vector 初始化新的 vector。\n\n```cpp\nstd::vector<int> myVector1 = {1, 2, 3};\nstd::vector<int> myVector2(myVector1); // 使用 myVector1 初始化 myVector2\n```\n\n* **多维数组:** 用 vector 来存储 vector。\n\n```cpp\nstd::vector<vector<int>> myVector(line, vector<int>(column, 0));// 定义一个 line 行 column 列的 vector\n```\n\n### 二、Vector 的常用函数\n\n**1. 访问元素**\n\n* **使用下标运算符 `[]`:** 访问指定位置的元素，不进行越界检查。\n\n```cpp\nint firstElement = myVector[0]; // 访问第一个元素\n```\n\n* **使用 `at()` 函数:** 访问指定位置的元素，进行越界检查，越界时抛出 `std::out_of_range` 异常。\n\n```cpp\nint secondElement = myVector.at(1); // 访问第二个元素\n```\n\n* **使用 `front()` 和 `back()` 函数:** 分别访问第一个和最后一个元素。\n\n```cpp\nint firstElement = myVector.front();\nint lastElement = myVector.back();\n```\n\n**2. 修改元素**\n\n* **使用下标运算符 `[]`:** 修改指定位置的元素。\n\n```cpp\nmyVector[0] = 10; // 修改第一个元素为 10\n```\n\n* **使用 `at()` 函数:** 修改指定位置的元素。\n\n```cpp\nmyVector.at(1) = 20; // 修改第二个元素为 20\n```\n\n* **使用 `assign()` 函数:** 将 vector 的内容替换为指定值或另一个 vector 的内容。\n\n```cpp\nmyVector.assign(5, 100); // 将 vector 的内容替换为 5 个 100\nmyVector.assign(myVector2.begin(), myVector2.end()); // 将 myVector 的内容替换为 myVector2 的内容\n```\n\n**3. 添加元素**\n\n* **使用 `push_back()` 函数:** 在 vector 的末尾添加一个元素。\n\n```cpp\nmyVector.push_back(6); // 在末尾添加元素 6\n```\n\n* **使用 `insert()` 函数:** 在指定位置插入一个或多个元素。\n\n```cpp\nmyVector.insert(myVector.begin() + 2, 7); // 在第三个位置插入元素 7\nmyVector.insert(myVector.end(), {8, 9, 10}); // 在末尾插入元素 8, 9, 10\n```\n\n**4. 删除元素**\n\n* **使用 `pop_back()` 函数:** 删除 vector 的最后一个元素。\n\n```cpp\nmyVector.pop_back(); // 删除最后一个元素\n```\n\n* **使用 `erase()` 函数:** 删除指定位置或范围内的元素。\n\n```cpp\nmyVector.erase(myVector.begin() + 2); // 删除第三个元素\nmyVector.erase(myVector.begin(), myVector.begin() + 3); // 删除前三个元素\n```\n\n* **使用 `clear()` 函数:** 删除 vector 中的所有元素。\n\n```cpp\nmyVector.clear(); // 删除所有元素\n```\n\n**5. 获取 vector 信息**\n\n* **使用 `size()` 函数:** 获取 vector 中元素的个数。\n\n```cpp\nint size = myVector.size();\n```\n\n* **使用 `capacity()` 函数:** 获取 vector 当前分配的存储空间大小。\n\n```cpp\nint capacity = myVector.capacity();\n```\n\n* **使用 `empty()` 函数:** 判断 vector 是否为空。\n\n```cpp\nif (myVector.empty()) {\n // vector 为空\n}\n```\n\n**6. 其他操作**\n\n* **使用 `swap()` 函数:** 交换两个 vector 的内容。\n\n```cpp\nmyVector1.swap(myVector2); // 交换 myVector1 和 myVector2 的内容\n```\n\n* **使用 `resize()` 函数:** 改变 vector 的大小。\n\n```cpp\nmyVector.resize(15); // 将 vector 的大小改为 15，新增元素初始化为 0\nmyVector.resize(20, 100); // 将 vector 的大小改为 20，新增元素初始化为 100\n```\n\n* **使用 `reserve()` 函数:** 预留存储空间，避免频繁重新分配内存。\n\n```cpp\nmyVector.reserve(100); // 预留 100 个元素的存储空间\n```\n\n### 三、Vector 的迭代器\n\nVector 提供了迭代器用于遍历元素：\n\n* **`begin()`:** 返回指向第一个元素的迭代器。\n* **`end()`:** 返回指向最后一个元素之后位置的迭代器。\n* **`rbegin()`:** 返回指向最后一个元素的逆向迭代器。\n* **`rend()`:** 返回指向第一个元素之前位置的逆向迭代器。\n\n```cpp\nfor (auto it = myVector.begin(); it != myVector.end(); ++it) {\n std::cout << *it << \" \";\n}\n```\n\n### 四、Vector 的优势与劣势\n\n**优势:**\n\n* **动态数组:** 可以根据需要自动调整大小，无需手动管理内存。\n* **高效访问:** 支持随机访问，访问任意元素的时间复杂度为 O(1)。\n* **丰富的操作:** 提供了丰富的成员函数，方便进行各种操作。\n\n**劣势:**\n\n* **插入/删除效率低:** 在中间位置插入或删除元素需要移动后续元素，时间复杂度为 O(n)。\n* **内存占用:** 需要额外的内存空间来存储容量信息。\n\n### 五、总结\n\nVector 是 C++ 中非常实用的容器，它提供了动态数组的功能，并支持各种操作。掌握 vector 的用法对于编写高效、易维护的 C++ 代码至关重要。",
      "tags": [
        "C++"
      ],
      "createTime": "2025-12-13T07:45:25.220Z"
    }
  ],
  "lastUpdate": "2025-12-14T05:14:26Z"
}
